{
	ZXTMGR v0.3 - Implementation of the ZXT standard, version 1.0.x

	Do not edit this file - edit the following files:
	- ZXTCONF.INC (configuration)
	- ZXTTYPES.INC (extension type enum)

	For API documentation, follow the comments in the "interface" section.

	Copyright (c) 2021 Adrian Siekierka

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
	RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
	CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
	CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
}

{$I-}
{$V-}
unit ZxtMgr;

interface
	uses GameVars;
	{ Type definitions. }
	type
{$I ZXTTYPES.INC}
		TExtensionId = record
			Owner: longint;
			Selector: word;
		end;
		TExtensionBlockHeader = record
			Flags: word;
			Id: TExtensionId;
			Reserved0: byte;
			FieldLength: word;
		end;
		TExtensionBlock = record
			ExtType: TExtensionType;
			Header: TExtensionBlockHeader;
			Data: pointer;
		end;
		PTExtensionBlock = ^TExtensionBlock;
		TExtensionHandlerAction = (
			ExtActionLoad,
			ExtActionUnload
		);
		TExtensionHandlerState = record
			Action: TExtensionHandlerAction;
		end;
		TExtensionHandlerResult = (
			ExtResultFatal, { Stop loading the file. }
			ExtResultFailure, { Ignore this extension. }
			ExtResultSuccess { Accept this extension. }
		);
		TExtensionHandlerFunc = function(var block: TExtensionBlock; var state: TExtensionHandlerState):
			TExtensionHandlerResult;
	const
		NULL_EXT_BLOCK = PTExtensionBlock(0);
		ZXT_APPEND_START = 0;
		ZXT_APPEND_END = 65535;
		{ .ZXT extension block flags (TExtensionBlockHeader.Flags) }
		FZxtExtParsingMust = $0001;
		FZxtExtReadingMust = $0002;
		FZxtExtWritingMust = $0004;
		FZxtExtPlayingShould = $0008;
		FZxtExtPlayingMust = $0010;
		FZxtExtEditingShould = $0020;
		FZxtExtPreserveShould = $0040;
		FZxtExtVanillaBehavior = $0080;
		FZxtExtBlockHeaderKnown = $00FF;
	var
		{ This is the primary way of checking if an extension is enabled.
		  ExtensionEnabled[ExtUnlockExtensions] will return true if at least
		  one extension of type ExtUnlockExtensions is active.
		  As Turbo Pascal 5.5 can fold these two constants into a direct memory
		  load, there are no major performance concerns involved. }
		ExtensionEnabled: array[ExtUnlockExtensions .. ExtTypeEnd] of boolean;
		{ True if the current world satisfies the "playing_should" requirement. }
		ExtensionPlayShould: boolean;
		{ True if the current world satisfies the "edit_should" requirement. }
		ExtensionEditShould: boolean;
		{ True if the current world satisfies the "writing_must" requirement. }
		ExtensionWriteCan: boolean;
	{ --- HOOKS --- }
	{ Load the .ZXT header or a separate .ZAX file for a given world file. }
	function ZxtLoadExtensions(var worldFile: file; filename: TString50): boolean;
	{ Unload the extension data for the current world file. }
	function ZxtUnloadExtensions: boolean;
	{ Write the .ZXT header to a given file. }
	function ZxtWriteExtensions(var extFile: file): boolean;
	{ Show all warnings based on the above requirement flags.
	  For errors, the above methods will return false. }
	function ZxtShowFlagError(isEditing: boolean): boolean;
	{ Get the TExtensionType for a given owner/selector pair. }
	function ZxtGetExtType(ownerId: longint; selectorId: word; var extType: TExtensionType): boolean;
	{ --- REGISTRATION --- }
	{ Register a simple extension, with no additional handler function.
	  This is useful for extensions which store no data, or store metadata not used
	  as part of the gameplay process. }
	procedure ZxtRegisterExtensionSimple(extType: TExtensionType; ownerId: longint; selectorId: word);
	{ Register an extension with a handler function. }
	procedure ZxtRegisterExtension(extType: TExtensionType; ownerId: longint; selectorId: word; handler: TExtensionHandlerFunc);
	{ --- BLOCK API --- }
	function ZxtBlockGetCount: word;
	{ Extension blocks are counted from 1 to ZxtBlockGetCount. }
	function ZxtBlockGet(i: word): PTExtensionBlock;
	function ZxtBlockGetCountByType(targetExtType: TExtensionType): word;
	{ Will return < 0, if not found. }
	function ZxtBlockGetIdByType(targetExtType: TExtensionType; offset: word): integer;
	{ May return NULL_EXT_BLOCK, if offset >= ZxtBlockGetCountByType. }
	function ZxtBlockGetByType(targetExtType: TExtensionType; offset: word): PTExtensionBlock;
	procedure ZxtBlockRemove(i: word);
	procedure ZxtBlockRemoveByType(targetExtType: TExtensionType);
	function ZxtBlockAppend(offset: word; var block: TExtensionBlock): boolean;

implementation
uses Dos, TxtWind;

const
{$I ZXTCONF.INC}
	MAX_EXTENSION_BLOCKS = 3072;
type
	TExtBlockArray = array[1 .. MAX_EXTENSION_BLOCKS] of TExtensionBlock;
	PTExtBlockArray = ^TExtBlockArray;
	TExtensionHeader = record
		Magic: integer;
		BlockCount: longint;
	end;
	TExtensionHandler = record
		Id: TExtensionId;
		HandlerFunc: TExtensionHandlerFunc;
	end;
var
	ExtensionBlocks: PTExtBlockArray;
	ExtensionBlockCount: word; { actually loaded extensions }
	ExtensionBlockSize: word; { array size }
	ExtensionHandlers: array[0 .. (Ord(ExtTypeEnd) - 1)] of TExtensionHandler;

{ --- HOOKS/INTERNAL --- }

{$F+}

function ZxtDefaultExtensionHandler(var block: TExtensionBlock; var state: TExtensionHandlerState):
	TExtensionHandlerResult;
begin
	ZxtDefaultExtensionHandler := ExtResultSuccess;
end;

{$F-}

procedure ZxtClearExtensions;
begin
	ExtensionPlayShould := true;
	ExtensionEditShould := true;
	ExtensionWriteCan := true;

	ExtensionBlockCount := 0;
	ExtensionBlockSize := 0;
end;

function ZxtUnloadExtensions: boolean;
var
	blockId: word;
	state: TExtensionHandlerState;
begin
	state.Action := ExtActionUnload;

	for blockId := 1 to ExtensionBlockSize do begin
		with ExtensionBlocks^[blockId] do begin
			if ExtensionHandlers[Ord(ExtType)].HandlerFunc(ExtensionBlocks^[blockId], state) <> ExtResultSuccess then begin
				ZxtUnloadExtensions := false;
				exit;
			end;

			if Header.FieldLength > 0 then begin
				FreeMem(Data, Header.FieldLength);
			end;

			ExtensionEnabled[ExtType] := false;
		end;
	end;

	FreeMem(ExtensionBlocks, SizeOf(TExtensionBlock) * ExtensionBlockSize);
	ZxtClearExtensions;
	ZxtUnloadExtensions := true;
end;

function ZxtLoadExtensions(var worldFile: file; filename: TString50): boolean;
var
	hdr: TExtensionHeader;
	bhdr: TExtensionBlockHeader;
	state: TExtensionHandlerState;
	zaxFile: file;
	extFile: ^file;
	bi: longint;
	extId: word;
	extFound: boolean;
label OnExtFound;
label OnError;
begin
	ZxtLoadExtensions := true;

	{ Clear all enabled extensions. }
	FillChar(ExtensionEnabled, Ord(ExtTypeEnd), 0);

	{ World.BoardCount is currently set to the world file's magic. }
	if World.BoardCount = ZXT_HEADER_MAGIC then begin
		{ .ZXT file. }
		extFile := @worldFile;

		{ Read extension header. }
		hdr.Magic := ZXT_HEADER_MAGIC;
		BlockRead(worldFile, hdr.BlockCount, 4);
	end else begin
		Assign(zaxFile, filename + '.ZAX');
		Reset(zaxFile, 1);
		if IOResult = 0 then begin
			{ .ZAX file. }
			extFile := @zaxFile;

			{ Read extension header. }
			BlockRead(extFile^, hdr, SizeOf(hdr));
		end else begin
			{ No extensions found. }
			exit;
		end;	
	end;

	{ Validate header. }
	if (IOResult <> 0) or (hdr.Magic <> ZXT_HEADER_MAGIC) or (hdr.BlockCount < 0)
	or (hdr.BlockCount > MAX_EXTENSION_BLOCKS) then begin
		ZxtLoadExtensions := false;
		goto OnError;
	end;

	ExtensionBlockCount := 0;
	ExtensionBlockSize := hdr.BlockCount;
	GetMem(ExtensionBlocks, SizeOf(TExtensionBlock) * ExtensionBlockSize);

	state.Action := ExtActionLoad;

	for bi := 1 to hdr.BlockCount do begin
		{ Parse extension. }
		BlockRead(extFile^, bhdr, SizeOf(bhdr));
		if (IOResult <> 0)
			or ((bhdr.Flags and (not FZxtExtBlockHeaderKnown)) <> 0)
			or (bhdr.FieldLength > 65519)
		then begin
			ZxtLoadExtensions := false;
			goto OnError;
		end;

		{ Figure out if we recognize this extension. }
		for extId := 0 to (Ord(ExtTypeEnd) - 1) do begin
			with ExtensionHandlers[extId].Id do begin
				if (bhdr.Id.Owner = Owner) and (bhdr.Id.Selector = Selector) then begin
					extFound := true;	
					goto OnExtFound;
				end;
			end;
		end;

		extFound := false;

	OnExtFound:
		{ Preserve the extension. }
		if extFound or ((bhdr.Flags and FZxtExtPreserveShould) <> 0) then begin
			Inc(ExtensionBlockCount);
			with ExtensionBlocks^[ExtensionBlockCount] do begin
				ExtType := TExtensionType(extId);
				Header := bhdr;
				if Header.FieldLength > 0 then begin
					GetMem(Data, Header.FieldLength);
					BlockRead(extFile^, Data^, Header.FieldLength);
				end;

				{ Load the extension. }
				if extFound then begin
					case ExtensionHandlers[Ord(ExtType)].HandlerFunc(ExtensionBlocks^[ExtensionBlockCount], state) of
					ExtResultFatal: begin
						ZxtLoadExtensions := false;
						goto OnError;
					end;
					ExtResultFailure: begin
						if ((bhdr.Flags and FZxtExtPreserveShould) = 0) then begin
							if Header.FieldLength > 0 then begin
								FreeMem(Data, Header.FieldLength);
							end;
							Dec(ExtensionBlockCount);
						end;
						extFound := false;
					end;
					ExtResultSuccess: begin
						ExtensionEnabled[TExtensionType(extId)] := true;
					end;
					end;
				end;
			end;
		end;

		if not extFound then begin
			{ Un-set flags, if we don't recognize it. }
			if (bhdr.Flags and (FZxtExtParsingMust or FZxtExtReadingMust)) <> 0 then begin
				ZxtLoadExtensions := false;
				goto OnError;
			end;
			if (bhdr.Flags and FZxtExtVanillaBehavior) = 0 then begin
				if (bhdr.Flags and FZxtExtPlayingMust) <> 0 then begin
					ZxtLoadExtensions := false;
					goto OnError;
				end;
				if (bhdr.Flags and FZxtExtPlayingShould) <> 0 then
					ExtensionPlayShould := false;
			end;
			if (bhdr.Flags and FZxtExtEditingShould) <> 0 then
				ExtensionEditShould := false;
			if (bhdr.Flags and FZxtExtWritingMust) <> 0 then
				ExtensionWriteCan := false;
		end;
	end;
OnError:
	{ Finish. }
	if World.BoardCount = ZXT_HEADER_MAGIC then begin
		{ .ZXT file. }
		BlockRead(extFile^, World.BoardCount, 2);
	end else begin
		{ .ZAX file. }
		Close(zaxFile);
	end;
end;

function ZxtWriteExtensions(var extFile: file): boolean;
var
	hdr: TExtensionHeader;
	bhdr: TExtensionBlockHeader;
	i: word;
	lenpos, retpos: longint;
label OnError;
begin
	if not ExtensionWriteCan then begin
	OnError:
		ZxtWriteExtensions := false;
		exit;
	end;

	hdr.Magic := ZXT_HEADER_MAGIC;
	hdr.BlockCount := ExtensionBlockCount;
	BlockWrite(extFile, hdr, SizeOf(hdr));
	if IOResult <> 0 then goto OnError;

	for i := 1 to ExtensionBlockCount do begin
		with ExtensionBlocks^[ExtensionBlockCount] do begin
			Header.Reserved0 := 0;

			BlockWrite(extFile, Header, SizeOf(Header));
			if (IOResult <> 0) then goto OnError;

			if Header.FieldLength > 0 then begin
				BlockWrite(extFile, Data^, Header.FieldLength);
				if (IOResult <> 0) then goto OnError;
			end;
		end;		
	end;

	ZxtWriteExtensions := true;
end;

function ZxtShowFlagError(isEditing: boolean): boolean;
var
	textWindow: TTextWindowState;
	isFatal: boolean;
begin
	isFatal := (isEditing) and (not ExtensionWriteCan);
	ZxtShowFlagError := isFatal;

	if isFatal then
		textWindow.Title := 'Error'
	else begin
		if (isEditing and ExtensionEditShould) or ((not isEditing) and ExtensionPlayShould) then
			exit;
		textWindow.Title := 'Warning';
	end;

	TextWindowInitState(textWindow);
	TextWindowAppend(textWindow, 'This world uses extensions which are');
	TextWindowAppend(textWindow, 'not supported by this version of the');
	TextWindowAppend(textWindow, 'game engine.');
	TextWindowAppend(textWindow, '');
	if isFatal then
		TextWindowAppend(textWindow, 'This action is unavailable.')
	else if isEditing then
		TextWindowAppend(textWindow, 'Editing may be negatively impacted.')
	else
		TextWindowAppend(textWindow, 'Playing may be negatively impacted.');

	TextWindowDrawOpen(textWindow);
	TextWindowSelect(textWindow, false, false);
	TextWindowDrawClose(textWindow);
	TextWindowFree(textWindow);
end;

{ Get the TExtensionType for a given owner/selector pair, if one exists. }
function ZxtGetExtType(ownerId: longint; selectorId: word; var extType: TExtensionType): boolean;
var
	i: word;
begin
	for i := 0 to (Ord(ExtTypeEnd) - 1) do begin
		with ExtensionHandlers[i].Id do begin
			if (ownerId = Owner) and (selectorId = Selector) then begin
				extType := TExtensionType(i);
				ZxtGetExtType := true;
				exit;
			end;
		end;
	end;
	ZxtGetExtType := false;
end;

{ --- REGISTRATION --- }

procedure ZxtRegisterExtensionSimple(extType: TExtensionType; ownerId: longint; selectorId: word);
begin
	ZxtRegisterExtension(extType, ownerId, selectorId, ZxtDefaultExtensionHandler);
end;

procedure ZxtRegisterExtension(extType: TExtensionType; ownerId: longint; selectorId: word; handler: TExtensionHandlerFunc);
begin
	with ExtensionHandlers[Ord(extType)] do begin
		Id.Owner := ownerId;
		Id.Selector := selectorId;
		HandlerFunc := handler;
	end;
end;

{ --- BLOCK API --- }

function ZxtBlockGetCount: word;
begin
	ZxtBlockGetCount := ExtensionBlockCount;
end;

function ZxtBlockGet(i: word): PTExtensionBlock;
begin
	if (i >= 1) and (i <= ExtensionBlockCount) then
		ZxtBlockGet := @ExtensionBlocks^[i];
end;

function ZxtBlockGetCountByType(targetExtType: TExtensionType): word;
var
	i, j: word;
begin
	j := 0;
	for i := 1 to ExtensionBlockCount do begin
		with ExtensionBlocks^[i] do begin
			if ExtType = targetExtType then
				Inc(j);
		end;
	end;
	ZxtBlockGetCountByType := j;
end;

function ZxtBlockGetIdByType(targetExtType: TExtensionType; offset: word): integer;
var
	i: word;
begin
	for i := 1 to ExtensionBlockCount do begin
		with ExtensionBlocks^[i] do begin
			if ExtType = targetExtType then begin
				if offset = 0 then begin
					ZxtBlockGetIdByType := i;
					exit;
				end;
				Dec(offset);
			end;
		end;
	end;
	ZxtBlockGetIdByType := -1;
end;

function ZxtBlockGetByType(targetExtType: TExtensionType; offset: word): PTExtensionBlock;
var
	i: word;
begin
	i := ZxtBlockGetIdByType(targetExtType, offset);
	if i >= 0 then
		ZxtBlockGetByType := @ExtensionBlocks^[i]
	else
		ZxtBlockGetByType := NULL_EXT_BLOCK;
end;

procedure ZxtBlockRemove(i: word);
var
	j: word;
begin
	if (i >= 1) and (i <= ExtensionBlockCount) then begin
		for j := (i) to (ExtensionBlockCount - 1) do
			ExtensionBlocks^[j] := ExtensionBlocks^[j + 1];
		Dec(ExtensionBlockCount);
	end;
end;

procedure ZxtBlockRemoveByType(targetExtType: TExtensionType);
var
	i: integer;
begin
	repeat
		i := ZxtBlockGetIdByType(targetExtType, 0);
		if i > 0 then ZxtBlockRemove(i) else exit;
	until 1 = 0;
end;

function ZxtBlockAppend(offset: word; var block: TExtensionBlock): boolean;
var
	newBlocks: PTExtBlockArray;
	newSize, i: word;
begin
	if offset > ExtensionBlockCount then offset := ExtensionBlockCount;

	{ If the ExtensionBlockSize is too small, copy it first. }
	if ExtensionBlockSize <= ExtensionBlockCount then begin
		newSize := ExtensionBlockCount + 4;
		GetMem(newBlocks, SizeOf(TExtensionBlock) * newSize);
		for i := 1 to ExtensionBlockCount do
			newBlocks^[i] := ExtensionBlocks^[i];
		FreeMem(ExtensionBlocks, SizeOf(TExtensionBlock) * ExtensionBlockSize);
		ExtensionBlocks := newBlocks;
		ExtensionBlockSize := newSize;
	end;

	{ Make room... }
	for i := ExtensionBlockCount downto (offset + 1) do begin
		ExtensionBlocks^[i + 1] := ExtensionBlocks^[i];
	end;
	ExtensionBlocks^[offset + 1] := block;
	Inc(ExtensionBlockCount);
end;

begin
	FillChar(ExtensionHandlers, SizeOf(ExtensionHandlers), 0);
	ZxtClearExtensions;
end.
